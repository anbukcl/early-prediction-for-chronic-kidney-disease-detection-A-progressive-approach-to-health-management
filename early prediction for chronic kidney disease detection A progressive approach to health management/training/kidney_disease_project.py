# -*- coding: utf-8 -*-
"""KIDNEY DISEASE.PROJECT

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XN3rJTCNtDgYeuhvF_QSHJtKEHv6tB9G
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
import pickle

data=pd.read_csv("/content/kidney_disease.csv")
data.head()

data.columns

data.columns=['id','age','blood_pressure','specific_gravity','albumin',
'sugar','red_blood_cell','pus_cell','pus_cell_clumps','bacteria',
'blood glucose random','blood_urea','serum_creatinine','sodium','potassium',
'hemoglobin','packed_cell_volume','white_blood_cell_count','red_blood_cell_count',
'hypertension','diabetesmellitus','coronary_artery_diseas','appetite',
'pedal_edema','anemia','class']#manually giving the name of the columns
data.columns

data.info()

data.isnull().any()

data['blood glucose random'].fillna(data['blood glucose random'].mean(),inplace=True)
data['blood_pressure'].fillna(data['blood_pressure'].mean(),inplace=True)
data['blood_urea'].fillna(data['blood_urea'].mean(),inplace=True)
data['hemoglobin'].fillna(data['hemoglobin'].mean(),inplace=True)
data['packed_cell_volume'].fillna(data['packed_cell_volume'].mean(),inplace=True)
data['potassium'].fillna(data['potassium'].mean(),inplace=True)
data['red_blood_cell_count'].fillna(data['red_blood_cell_count'].mean(),inplace=True)
data['serum_creatinine'].fillna(data['serum_creatinine'].mean(),inplace=True)
data['sodium'].fillna(data['sodium'].mean(),inplace=True)
data['white_blood_cell_count'].fillna(data['white_blood_cell_count'].mean(),inplace=True)

data['age'].fillna(data['age'].mode()[0],inplace=True)
data['hypertension'].fillna(data['hypertension'].mode()[0],inplace=True)
data['pus_cell_clumps'].fillna(data['pus_cell_clumps'].mode()[0],inplace=True)
data['appetite'].fillna(data['appetite'].mode()[0],inplace=True)
data['albumin'].fillna(data['albumin'].mode()[0],inplace=True)
data['pus_cell'].fillna(data['pus_cell'].mode()[0],inplace=True)
data['red_blood_cells'].fillna(data['red_blood_cells'].mode()[0],inplace=True)
data['coronary_artery_diseas'].fillna(data['coronary_artery_disease'].mode()[0],inplace=True)
data['bacteria'].fillna(data['bacteria'].mode()[0],inplace=True)
data['anemia'].fillna(data['anemia'].mode()[0],inplace=True)
data['sugar'].fillna(data['sugar'].mode()[0],inplace=True)
data['diabetesmellitus'].fillna(data['coronary_artery_disease'].mode()[0],inplace=True)
data['pedal_edema'].fillna(data['pedal_edema'].mode()[0],inplace=True)
data['specific_gravity'.fillna(data['specific_gravity'].mode()[0],inplace=True)

catcols=set(data.dtypes[data.dtypes=='0'].index.values)
print(catcols)

for i in catcols:
  print("columns:",i)
  print(c(data[i]))
  print('*'*120+'\n')

catcols.removed('red_blood_cell_count')
catcols.remove('packed_cell_volume')
catcols.remove('white_blood_cell_count')
print(catcols)

contcols=set(data.dtypes[data.dtypes!='0'].index.values)
print(contcols)

for i in contcols:
  print("continous columns:",i)
  print(c(data[i]))
  print('*'*120+'\n')

contcols.removed('specific-gravity')
contcols.removed('albumin')
contcols.removed('sugar')
print(contcols)

data.replace()

data['coronary_artery_disease']=data.coronary_artery_disease.replace('\tno','no')
c(data['coronary_artery_disease'])

data['diabetesmellitus']=data.diabetesmellitus.replace={'\tno':'no','\tyes','yes','yes':
c(data['diabetesmellitus'])

"""task3"""

data.describe()

sns.displot(data.age)

import matplotlib.pyplot as plt
fig=plt.figure(figsize=(5,5))
plt.scatter(data['age'],data['blood_pressure'],color='blue')
plt.xlabel('age')
plt.ylabel('blood pressure')
plt.title("ageVSblood scatter plot")

plt.figure(figsize=(20,15), facecolor='white')
plotnumber = 1


for column in contcols:
   if plotnumber<=11  :
      ax = plt.subplot(3,4,plotnumber)
      plt.scatter(data['age'],data[column])
      plt.xlabel(column,fontsize=20)

    plotnumber+=1 
 plt.show()

f,ax=plt.subplots(figsize=(18,10))
sns.heatmap(data.corr(),annot=True,fmt="2f",ax=ax,linewidths=0.5,linecolor="orange")
plt.xticks(roation=45)
plt.yticks(rotation=45)
plt.show()

sns.countplot(data['class'])

from sklearn.preprocessing import  StandardScaler
sc=StandardScaler
x_bal=sc.fit_transform(X)

selcols=['red_blood_cell','pus_cell','blood glucose random','blood_urea',
         'pedal_edema','anemia','diabetesmelliitus','coronary_artery_disease']
x=pd.Datframea(data,columns=selcols)
y=pd.dataframe(data,columns=['class'])
print(x.shape)
print(y.shape)

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=2)

"""task 4"""

import tensorflow
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import

classification=sequential()
classification.add(Dense(30,activation='relu'))
classification.add(Dense(128,activation='relu'))
classification.add(Dene(64,activation='relu'))
classification.add(Dense(32,activation='relu'))
classification.add(Dense(1,activation='sogmoid'))

classification.compile(optimizer='adam',loss='binary_crossentropy',metrics=[accuracy])

classification.fit(x_train,y_train,batch_size=10,validation_split=0,2,epochs=100)

from  sklearn.ensemble import Randomforestclassifier
rfc = RandomForestclassifier(n_estimators=10,criterion='entropy')

rfc.fit(x_train,y_train)

y_predict = rfc.predict(x_test)

y_predict_train = rfc.predict(x_train)

from sklearn.tree import DecisionTreeClassifier
dtc = DecisionTreeClassifier(max_depth=4,splitter='best',criterion='entropy')

dtc.fit(x_train,y_train)

y_predict= dtc.predict(x_test)
y_predict

y_predict_train = dtc.predict(x_train)

from sklearn import linear_model import LogisticRegression
lgr = LogisticRegression()
lgr.fit(x_train,y_train)

, classification_report

from sklearn.metrics import accuracy_score,classification_report
y_predict = lgr.predict(x_test)

y_pred = lgr.predict([[1,1,121.000000,36.0,0,0,1,0]])
print(y_pred)
(y_pred)

y_pred - dtc.predict([[1,1,121.000000,36.0,0,1,0]])
print(y_pred)
(y_pred)

y_pred = rfc.predict([[1,1,121.000000,36.0,0,0,1,0]])
print(y_pred)
(y_pred)

classification.save("ckd.hs")

y_pred

y_pred = (y_pred > 0.5)
y_pred

def predict_exit(sample_value):
  sample_value = np.array(sample_value)
  sample_value = sample_value.reshape(1, -1)
  sample_value = sc.transform(sample_value)
  return classifier.predict(sample_value)

rest=classification.predict([[1,1,121.000000,36.0,0,0,1,0]])
if test==1:
      print('prediction: High chance of CKD!')
else:
      print('prediction: Low chance of CKD.')

"""task 5

"""

from sklearn import model_selection

from os import name
from sklearn.exceptions import FitFailedWarning
KFold,
      dfs = []
models = [
          ('LogReg',LogisticRegression()),
          ('RF',RandomForestclassifier()),
          ('DecisionTree',DecisionTreeClassifier()),
         ] 
results = []
     names = []
     scoring = ['accuracy','precision_weighted','recall_weighted','f1_weighted','roc_auc']
     target_name = ['NO CKD','CKD']
     for name,model in models:
           Kfold = model_selection.KFold(n_splits=5,shuffle=true,random_state=90210)
           CV_results = model_selection.cross_validate(model,x_train,y_train,cv=kfold,scoring=scoring)
           clf = model.Fit(x_train,y_train)
           y_pred = clf.predict(x_test)
           print(name)
           print(classification_report(y_test,y_pred,target_names=target_names))
           results.append(cv_results)
           names.append(name)
           this_df = pd.dataframe(cv_results)
           this_df['model'] = name
           dfs.append(this_df)
     final = pd.concat(dfs,ignore_index=true)
     return final

from sklearn.mertics import confusion_matrix
cm = confusion_matrix(y_test,y_predict)
cm

plt.plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='blues',annot=true,xticklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('actual value')
plt.title('confusion matrix for logistic regression model')
plt.show()

from sklearn.metrics import confusion_matrix
cm-confusion_matrix(y_test,y_predict)
cm

plt.figure(figsize-(8,6))
sns.heatmap(cm,cmap-'blues',annot-true,xticklabels=['no ckd','ckd'],yticklabels=['no ckd''ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for randomforestclassifier')
plt.show()

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test,y_predict)
cm

plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='Blues',annot=true,xtricklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for DecisionTreeClassifier')
plt.show()

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test,y_pred)
cm

plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='Blues',annot=True,xticklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for ANN model')
plt.show()

from sqlalchemy.sql.expression import true
bootstraps = []
for model in list(set(final.model.values)):
    model_df = final.loc[final.model == model] 
    bootstrap = model_df.sample(n=30,replace=true) 
    bootstraps.append(bootstrap)
bootstrap_df = pd.concat(bootstraps,igore_index=true)  
results_long = pd.melt(bootstrap_df,id_vars=['model'],var_name='metrcs',value_name='values')
time_metrics = ['fit_time','score_time']# fit time matrics
## PERFORMANCE METRICS
results_long_nofit = results_long.loc[~results_long['metrics'].isin(time_metrics)]# get df without fit data
results_long_nofit = results_long_nofit.sort_values(by='values')
## TIME METRICS
results_long_fit = results_long.loc[results_long['metrics'].isin(time_metrics)] # df with fit data
results_long_fit = results_long_fit.sort_values(by='values')

import matplotlip.pyplot as plt
import seaborn as sns
plt.figure(figsize=(20,12))
sns.set(font_scale=2.5)
g = sns.boxplot(x="model",y="values",hue="metrics",data=result_long_nofit,palette="set3")
plt.legend(bbox_to_anchor=(1.05,1),loc=2,borderaxespad=0.)
plt.title('comparison of model by classificartion metric')
plt.savefig('./benchmark_models_performance.png',dpi=300)

"""task 6"""

pickle.dump(lgr, open('CKD.pkl','wb'))

from flask import flask,render_template,request
import numpy as np
import pickle

app = flask(_name_) # initializing a flask app
model = pickle.load(open('CKD.pkl','rb')) # loading the model

@app.route('/') # route to display the home page
def home():
    return render_template('home.html') # rendering the home page

@app.route('/prediction',methods=['POST','GET'])
def prediction():
    return render_template('indexnew.html')
@app.route('/Home',methods=['POST','GET'])
def my_home():
    return render_template('home.html')
@app.route('/predict',methods=['POST']) # route to show the predictions in a web UI
def predict():
    #reading the inouts given by the user
    input_features = [float(x) for x in request.form.values()]
    features_values = [np.array(input_features)]
    features_name = ['blood_urea','blood glucose random','anemia',
                     'coronary_artery_disease','pus_cell','red_blood_cells',
                     'diabetesmellitus','pedal_edema']
    df = pd.Dataframe(features_value,columns=features_name)
    # predictions using the loaded model file
    output = model.predict(df)

# showing the prediction results in a UI# showing the prediction results in a UI
return render_template('results.html',prediction_text=output)

if_name_=='_main_'
   # running the app
   app.run(debug=true)